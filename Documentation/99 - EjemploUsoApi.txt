Como usar?
üìå 1. Configurar appsettings.json
    Aseg√∫rate de que en appsettings.json exista la cadena de conexi√≥n:
        {
            "ConnectionStrings": {
                "DefaultConnection": "Server=myServer;Database=myDB;User Id=myUser;Password=myPassword;"
            }
        }
üìå 2. Registrar ConexionSql en Program.cs
    Para usar ConexionSql, debemos agregarlo a los servicios de builder.Services:

        using AccesoDatos; //NameSpace de ConexionSql
        using Microsoft.Extensions.DependencyInjection;

        var builder = WebApplication.CreateBuilder(args);

        // üöÄ Configurar servicios y dependencias
        builder.Services.AddControllers();
        builder.Services.AddEndpointsApiExplorer();
        builder.Services.AddSwaggerGen();

        // üöÄ Inyecci√≥n de dependencias
        builder.Services.AddScoped<ConexionSql>();         // Gestiona la conexi√≥n con la base de datos
        builder.Services.AddScoped<ArticuloLogicaNego>(); // Maneja la l√≥gica de negocio

        var app = builder.Build();

        // üöÄ Configuraci√≥n de middleware
        if (app.Environment.IsDevelopment())
        {... mas codigo ...


    üîπ builder.Services.AddScoped<ConexionSql>(); // Inyecci√≥n de dependencia
        üîπ AddScoped<ConexionSql>() ‚Üí Crea una instancia por cada solicitud HTTP, asegurando buena gesti√≥n de la conexi√≥n.

üìå 3. Inyectar ConexionSql en ArticuloLogicaNego
    As√≠ aseguramos que las operaciones CRUD se hagan desde la capa de l√≥gica de negocios:

        public class ArticuloLogicaNego {
            private readonly ConexionSql _conexion;
            public ArticuloLogicaNego(ConexionSql conexion) {
                _conexion = conexion;
            }

            public async Task<List<Articulo>> ObtenerTodos() {
                try{
                    var dt = await _conexion.EjecutarConsultaDTAsync("SELECT * FROM Articulos", CommandType.Text, null);
                    return dt.AsEnumerable()
                            .Select(row => new Articulo
                            {
                                Id = row.Field<int>("Id"),
                                Nombre = row.Field<string>("Nombre"),
                                Precio = row.Field<decimal>("Precio")
                            })
                            .ToList();
                }catch (Exception ex) {
                    Console.WriteLine($"Error al obtener art√≠culos: {ex.Message}"); // Log del error
                    return new List<Articulo>(); // Retorna lista vac√≠a en caso de error
                }
            }
        }
    üîπ El constructor recibe ConexionSql autom√°ticamente gracias a la inyecci√≥n de dependencias. 
    üîπ El m√©todo ObtenerTodos() ejecuta la consulta y convierte DataTable en una lista de objetos Articulo.

üìå 4. Usar ParametrosSql para consultas din√°micas
    Si quieres filtrar por ID, puedes utilizar ParametrosSql as√≠:

        public async Task<Articulo> ObtenerPorId(int id) {
            var parametros = new ParametrosSql();
            parametros.AgregarParametro("@Id", id, SqlDbType.Int);

            var dt = await _conexion.EjecutarConsultaDTAsync("SELECT * FROM Articulos WHERE Id = @Id", CommandType.Text, parametros);
            
            return dt.AsEnumerable()
                    .Select(row => new Articulo
                    {
                        Id = row.Field<int>("Id"),
                        Nombre = row.Field<string>("Nombre"),
                        Precio = row.Field<decimal>("Precio")
                    })
                    .FirstOrDefault();
        }
    üîπ Se usa ParametrosSql para evitar SQL Injection. 
    üîπ Si la consulta no devuelve datos, FirstOrDefault() retorna null en lugar de generar error.

üìå 5. Implementar CRUD completo
    5.1 Crear nuevo art√≠culo
        public async Task<int> Crear(Articulo articulo) {
            var parametros = new ParametrosSql();
            parametros.AgregarParametro("@Nombre", articulo.Nombre, SqlDbType.VarChar);
            parametros.AgregarParametro("@Precio", articulo.Precio, SqlDbType.Decimal);

            return await _conexion.EjecutarSentenciaAsync("INSERT INTO Articulos (Nombre, Precio) VALUES (@Nombre, @Precio)", CommandType.Text, parametros);
        }
    üîπ Devuelve el n√∫mero de registros insertados. 
    üîπ Usa par√°metros para evitar SQL Injection.

    5.2 Actualizar art√≠culo (Incluye uso de RollbackTransaccion)
        public async Task<int> Actualizar(Articulo articulo){
            try{
                _conexion.IniciarTransaccion(); // üîπ Comienza la transacci√≥n

                var parametros = new ParametrosSql();
                parametros.AgregarParametro("@Id", articulo.Id, SqlDbType.Int);
                parametros.AgregarParametro("@Nombre", articulo.Nombre, SqlDbType.VarChar);
                parametros.AgregarParametro("@Precio", articulo.Precio, SqlDbType.Decimal);

                int registrosAfectados = await _conexion.EjecutarSentenciaAsync(
                    "UPDATE Articulos SET Nombre = @Nombre, Precio = @Precio WHERE Id = @Id", 
                    CommandType.Text, parametros);

                _conexion.CommitTransaccion(); // üîπ Confirma los cambios si todo sali√≥ bien

                return registrosAfectados;
            }catch (Exception ex){
                _conexion.RollbackTransaccion(); // üîπ Revierte los cambios si hay un error
                Console.WriteLine($"Error en la actualizaci√≥n: {ex.Message}");
                return 0; // Se retorna 0 si hubo error
            }
        }

    Explicaci√≥n paso a paso
        1Ô∏è‚É£ IniciarTransaccion() ‚Üí Crea una transacci√≥n antes de ejecutar la consulta. 
        2Ô∏è‚É£ Ejecuta la sentencia UPDATE normalmente. 
        3Ô∏è‚É£ Si la ejecuci√≥n es exitosa, CommitTransaccion() confirma los cambios. 
        4Ô∏è‚É£ Si ocurre un error, RollbackTransaccion() revierte los cambios para evitar datos inconsistentes. 
        5Ô∏è‚É£ Se captura la excepci√≥n y se registra el error, devolviendo 0 si hubo un problema.

    üî• ¬øCu√°ndo es √∫til Rollback?
        ‚úÖ Si hay varias operaciones relacionadas y queremos asegurar que todas se completen correctamente (por ejemplo, actualizar m√∫ltiples registros en distintas tablas). 
        ‚úÖ Si queremos evitar datos inconsistentes ‚Üí Un rollback asegura que los cambios no queden a medias en la BD si algo falla.
        üîπ Ejemplo de escenario real: 
            Si Actualizar() se usa dentro de un proceso mayor, como actualizar productos y stock en distintas tablas, 
            el rollback evitar√≠a que queden registros corruptos si algo falla.

    5.3 Eliminar art√≠culo (Solo por fines didacticos)
        public async Task<int> Eliminar(int id) {
            var parametros = new ParametrosSql();
            parametros.AgregarParametro("@Id", id, SqlDbType.Int);

            return await _conexion.EjecutarSentenciaAsync("DELETE FROM Articulos WHERE Id = @Id", CommandType.Text, parametros);
        }
    üîπ Evita eliminaciones accidentales usando un filtro por Id.
    üîπ RECUERDA, las eliminaciones deben ser logicas no fisicas.

üìå 6. Usar ArticuloLogicaNego en el controlador
        public class ArticuloController : ControllerBase {
            private readonly ArticuloLogicaNego _articuloLogica;

            public ArticuloController(ArticuloLogicaNego articuloLogica) {
                _articuloLogica = articuloLogica;
            }

            [HttpGet]
            public async Task<IActionResult> ObtenerTodos() {
                var articulos = await _articuloLogica.ObtenerTodos();
                return Ok(articulos);
            }

            [HttpGet("{id}")]
            public async Task<IActionResult> ObtenerPorId(int id) {
                var articulo = await _articuloLogica.ObtenerPorId(id);
                return articulo != null ? Ok(articulo) : NotFound();
            }

            [HttpPost]
            public async Task<IActionResult> Crear([FromBody] Articulo articulo) {
                var registrosAfectados = await _articuloLogica.Crear(articulo);
                return registrosAfectados > 0 ? Ok("Art√≠culo creado correctamente.") : BadRequest("Error al crear el art√≠culo.");
            }

            [HttpPut]
            public async Task<IActionResult> Actualizar([FromBody] Articulo articulo) {
                var registrosAfectados = await _articuloLogica.Actualizar(articulo);
                return registrosAfectados > 0 ? Ok("Art√≠culo actualizado correctamente.") : NotFound("El art√≠culo no existe.");
            }

            [HttpDelete("{id}")]
            public async Task<IActionResult> Eliminar(int id) {
                var registrosAfectados = await _articuloLogica.Eliminar(id);
                return registrosAfectados > 0 ? Ok("Art√≠culo eliminado correctamente.") : NotFound("El art√≠culo no existe.");
            }
        }
    üîπ Ahora ArticuloController delega TODA la l√≥gica de negocio a ArticuloLogicaNego. 
    üîπ El controlador solo gestiona las respuestas HTTP (Ok, NotFound, BadRequest). üîπ Este enfoque mantiene el c√≥digo modular, limpio y reutilizable.