ğŸ“Œ DocumentaciÃ³n de Uso - ConexionSql.cs
DescripciÃ³n
Este documento proporciona una guÃ­a detallada sobre el uso de ConexionSql.cs, incluyendo la inyecciÃ³n de dependencias, la ejecuciÃ³n de consultas y el manejo adecuado de transacciones.

ğŸ”¹ 1. InyecciÃ³n de Dependencias
    Para utilizar ConexionSql, debemos inyectarlo en el contenedor de servicios en Program.cs:

        // ğŸ“Œ ConfiguraciÃ³n en `Program.cs`
        builder.Services.AddScoped<ConexionSql>();         // Gestiona la conexiÃ³n con la base de datos
        builder.Services.AddScoped<ArticuloLogicaNego>(); // Maneja la lÃ³gica de negocio

    ğŸ“¢ Nota: ParametrosSql NO se inyecta, ya que es una clase auxiliar que se crea cuando se necesita en cada consulta.

ğŸ”¹ 2. GestiÃ³n de ConexiÃ³n
    âœ… ConexionSql.cs abre y cierra la conexiÃ³n automÃ¡ticamente, por lo que NO es necesario llamarla manualmente. ğŸš« NO debes hacer esto:

        try {
            conexion.AbrirConexion(); // âŒ No es necesario llamarlo manualmente
            // Operaciones con la base de datos...
        } finally {
            conexion.CerrarConexion(); // âŒ No es necesario cerrarlo manualmente
        }
    ğŸš« Tampoco debes crear instancias manualmente, ya que la conexiÃ³n estÃ¡ inyectada en el contenedor de servicios:

        using (var conexion = new ConexionSql(configuration)) // âŒ No se debe hacer asÃ­ { 
            // La conexiÃ³n ya estÃ¡ administrada por inyecciÃ³n de dependencias
        }
    âœ… Siempre usa la variable inyectada dentro de la lÃ³gica de negocios (ArticuloLogicaNego).

ğŸ”¹ 3. Manejo de Transacciones
    Cuando se requiere asegurar que un conjunto de operaciones se ejecuten todas o ninguna, utilizamos transacciones con commit y rollback:

    conexion.IniciarTransaccion();
    try {
        // ğŸ› ï¸ Operaciones dentro de la transacciÃ³n...
        conexion.CommitTransaccion(); // âœ… Confirma los cambios en la BD
    } catch {
        conexion.RollbackTransaccion(); // ğŸ”„ Revierte los cambios si hay error
        throw;
    }
    ğŸ“Œ Siempre usar rollback si ocurre un error para evitar inconsistencias en la base de datos.

ğŸ”¹ 4. EjecuciÃ³n de Consultas
    ğŸ“Œ Consultas que devuelven un DataTable

        var parametros = new ParametrosSql();
        parametros.AgregarParametro("@categoriaId", 3, SqlDbType.Int);

        var productos = await _conexion.EjecutarConsultaDTAsync("SELECT * FROM Productos WHERE CategoriaId = @categoriaId", CommandType.Text, parametros);

        foreach (DataRow row in productos.Rows) {
            Console.WriteLine(row["Nombre"]);
        }

    ğŸ“Œ Si DataTable se convierte inmediatamente en una lista, usar EjecutarConsultaListaAsync() es mejor.
    ğŸ“Œ Consultas que devuelven una lista (EjecutarConsultaListaAsync)
        Si siempre necesitas los datos como una lista de objetos, podrÃ­amos definir este mÃ©todo:

            public async Task<List<T>> EjecutarConsultaListaAsync<T>(string sql, CommandType tipo, ParametrosSql parametros, Func<DataRow, T> mapear) {
                using (var comando = CrearComando(sql, tipo, parametros, DefaultTimeout))
                using (var reader = await comando.ExecuteReaderAsync()){
                    var dt = new DataTable();
                    dt.Load(reader);
                    return dt.AsEnumerable().Select(mapear).ToList();
                }
            }
        ğŸ”¹ Ejemplo de uso:

            var articulos = await _conexion.EjecutarConsultaListaAsync("SELECT * FROM Articulos", 
                    CommandType.Text, null, 
                    row => new Articulo {
                        Id = row.Field<int>("Id"),
                        Nombre = row.Field<string>("Nombre"),
                        Precio = row.Field<decimal>("Precio")
                    });
        âœ… Ahora ArticuloLogicaNego no necesita hacer la conversiÃ³n manual.

ğŸ”¹ 5. EjecuciÃ³n de Comandos (INSERT/UPDATE/DELETE)
    ğŸ“Œ Siempre usar ParametrosSql para evitar SQL Injection.

        var parametros = new ParametrosSql();
        parametros.AgregarParametro("@nombre", "Nuevo Producto", SqlDbType.NVarChar);
        parametros.AgregarParametro("@precio", 99.99m, SqlDbType.Decimal);

        int filasAfectadas = await _conexion.EjecutarSentenciaAsync(
            "INSERT INTO Productos (Nombre, Precio) VALUES (@nombre, @precio)", 
            CommandType.Text, 
            parametros);
    âœ… Este mÃ©todo devuelve el nÃºmero de registros afectados.

ğŸ”¹ 6. Manejo de Rollback en Actualizar()
    Cuando se actualizan datos, es recomendable usar transacciones para evitar inconsistencias:

        public async Task<int> Actualizar(Articulo articulo) {
            try {
                _conexion.IniciarTransaccion();

                var parametros = new ParametrosSql();
                parametros.AgregarParametro("@Id", articulo.Id, SqlDbType.Int);
                parametros.AgregarParametro("@Nombre", articulo.Nombre, SqlDbType.VarChar);
                parametros.AgregarParametro("@Precio", articulo.Precio, SqlDbType.Decimal);

                int registrosAfectados = await _conexion.EjecutarSentenciaAsync(
                    "UPDATE Articulos SET Nombre = @Nombre, Precio = @Precio WHERE Id = @Id",
                    CommandType.Text, parametros);

                _conexion.CommitTransaccion();
                return registrosAfectados;
            } catch (Exception ex) {
                _conexion.RollbackTransaccion();
                Console.WriteLine($"Error en la actualizaciÃ³n: {ex.Message}");
                return 0;
            }
        }
    âœ… Si ocurre un error, los cambios NO se aplicarÃ¡n.

ğŸ”¹ 7. Buenas PrÃ¡cticas
    âœ”ï¸ Usar transacciones para garantizar operaciones atÃ³micas. 
    âœ”ï¸ Siempre usar ParametrosSql para evitar SQL Injection. 
    âœ”ï¸ Evitar instancias manuales de ConexionSql, ya que la inyecciÃ³n de dependencias administra la conexiÃ³n. 
    âœ”ï¸ Preferir mÃ©todos asÃ­ncronos (async/await) en aplicaciones concurrentes. 
    âœ”ï¸ Configurar timeout adecuado para operaciones largas.

ğŸ”¹ 8. Ejemplo Completo - TransacciÃ³n Completa

    using (var conexion = _conexion) // ğŸ“Œ Usa la instancia inyectada{
        conexion.IniciarTransaccion();
        try {
            var parametrosCat = new ParametrosSql();
            parametrosCat.AgregarParametro("@nombre", "ElectrÃ³nicos", SqlDbType.NVarChar);

            int catId = (int)conexion.EjecutarEscalar(
                "INSERT INTO Categorias (Nombre) OUTPUT INSERTED.Id VALUES (@nombre)",
                CommandType.Text,
                parametrosCat);

            var dtProductos = new DataTable();
            dtProductos.Columns.Add("Nombre", typeof(string));
            dtProductos.Columns.Add("Precio", typeof(decimal));
            dtProductos.Columns.Add("CategoriaId", typeof(int));

            dtProductos.Rows.Add("TV 4K", 499.99m, catId);
            dtProductos.Rows.Add("Smartphone", 299.99m, catId);

            conexion.EjecutarMasivoDT("dbo.Productos", dtProductos);

            conexion.CommitTransaccion();
        } catch (Exception ex) {
            conexion.RollbackTransaccion();
            Console.WriteLine($"Error en la transacciÃ³n: {ex.Message}");
            throw;
        }
    }

ğŸš€ Â¡Ahora a programar...!!